/**
 * README.md è‡ªåŠ¨æ›´æ–°å·¥å…·
 * ç”¨äºåœ¨å¤šè¯­è¨€ç¿»è¯‘å®Œæˆåè‡ªåŠ¨æ›´æ–°ä¸» README.md æ–‡ä»¶
 * æ·»åŠ ç¿»è¯‘è¯­è¨€åˆ—è¡¨å’Œé“¾æ¥
 */

interface TranslationInfo {
  language: string
  path: string
  translatedContent?: string
}

interface RepositoryInfo {
  owner: string
  name: string
  defaultBranch: string
}

const LANGUAGE_NAMES: Record<string, string> = {
  en: 'English',
  'zh-CN': 'ç®€ä½“ä¸­æ–‡',
  zh: 'ç®€ä½“ä¸­æ–‡',
  'zh-TW': 'ç¹é«”ä¸­æ–‡',
  ja: 'æ—¥æœ¬èª',
  ko: 'í•œêµ­ì–´',
  es: 'EspaÃ±ol',
  fr: 'FranÃ§ais',
  de: 'Deutsch',
  ru: 'Ğ ÑƒÑÑĞºĞ¸Ğ¹',
  pt: 'PortuguÃªs',
  it: 'Italiano',
  ar: 'Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©',
  hi: 'à¤¹à¤¿à¤¨à¥à¤¦à¥€',
  nl: 'Nederlands',
  pl: 'Polski',
  tr: 'TÃ¼rkÃ§e',
  vi: 'Tiáº¿ng Viá»‡t',
  th: 'à¹„à¸—à¸¢',
  id: 'Bahasa Indonesia',
  ms: 'Bahasa Melayu',
}

/**
 * ä»ç¿»è¯‘æ–‡ä»¶è·¯å¾„ä¸­æå–è¯­è¨€ä»£ç 
 */
function extractLanguageFromPath(path: string): string | null {
  const match = path.match(/translations\/([a-zA-Z-]+)\//)
  return match ? match[1] : null
}

/**
 * è·å–è¯­è¨€åç§°
 */
function getLanguageName(code: string): string {
  return LANGUAGE_NAMES[code] || code
}

/**
 * ç”Ÿæˆå¤šè¯­è¨€ç¿»è¯‘åˆ—è¡¨çš„ Markdown å†…å®¹
 */
export function generateTranslationListMarkdown(
  translations: TranslationInfo[],
  repoInfo: RepositoryInfo
): string {
  if (translations.length === 0) {
    return ''
  }

  // æŒ‰è¯­è¨€åˆ†ç»„
  const translationsByLang = new Map<string, Set<string>>()

  for (const translation of translations) {
    const lang = translation.language
    if (!translationsByLang.has(lang)) {
      translationsByLang.set(lang, new Set())
    }
    translationsByLang.get(lang)!.add(translation.path)
  }

  // ç”Ÿæˆ Markdown å†…å®¹
  let markdown = `\n## ğŸŒ Translations / å¤šè¯­è¨€ç¿»è¯‘\n\n`
  markdown += `This repository is available in the following languages:\n\n`

  for (const [lang, paths] of translationsByLang.entries()) {
    const langName = getLanguageName(lang)
    const readmePath = Array.from(paths).find(p =>
      p.toLowerCase().includes('readme')
    )

    if (readmePath) {
      // è®¡ç®—ç›¸å¯¹è·¯å¾„
      const relativePath = readmePath.replace(/^translations\/[a-zA-Z-]+\//, '')
      markdown += `- [${langName}](./${readmePath})\n`
    } else {
      markdown += `- ${langName} (Coming soon)\n`
    }
  }

  markdown += `\n---\n\n`

  return markdown
}

/**
 * æ›´æ–° README.md å†…å®¹ï¼Œæ’å…¥æˆ–æ›´æ–°å¤šè¯­è¨€ç¿»è¯‘åˆ—è¡¨
 */
export function updateReadmeWithTranslations(
  originalReadme: string,
  translations: TranslationInfo[],
  repoInfo: RepositoryInfo
): string {
  const translationList = generateTranslationListMarkdown(translations, repoInfo)

  if (!translationList) {
    return originalReadme
  }

  // æ£€æŸ¥æ˜¯å¦å·²æœ‰å¤šè¯­è¨€ç¿»è¯‘éƒ¨åˆ†
  const existingSectionRegex = /## ğŸŒ Translations?[^\n]*[\s\S]*?(?=^## |$)/m
  const hasExistingSection = existingSectionRegex.test(originalReadme)

  if (hasExistingSection) {
    // æ›¿æ¢ç°æœ‰éƒ¨åˆ†
    return originalReadme.replace(existingSectionRegex, translationList)
  }

  // åœ¨å¤šè¯­è¨€ç¿»è¯‘éƒ¨åˆ†æ·»åŠ åˆ° README å¼€å¤´ï¼ˆåœ¨ç¬¬ä¸€ä¸ªæ ‡é¢˜ä¹‹åï¼‰
  const firstHeaderIndex = originalReadme.indexOf('#')
  if (firstHeaderIndex === -1) {
    // æ²¡æœ‰æ ‡é¢˜ï¼Œæ·»åŠ åˆ°å¼€å¤´
    return translationList + originalReadme
  }

  // æ‰¾åˆ°ç¬¬ä¸€ä¸ªæ ‡é¢˜çš„ç»“æŸä½ç½®
  const firstHeaderEndIndex = originalReadme.indexOf('\n', firstHeaderIndex)
  if (firstHeaderEndIndex === -1) {
    return originalReadme + translationList
  }

  // æ’å…¥åˆ°ç¬¬ä¸€ä¸ªæ ‡é¢˜ä¹‹å
  const insertPosition = firstHeaderEndIndex + 1
  return (
    originalReadme.slice(0, insertPosition) +
    translationList +
    originalReadme.slice(insertPosition)
  )
}

/**
 * ç”Ÿæˆ README.md çš„æ›´æ–° commit æ¶ˆæ¯
 */
export function generateReadmeUpdateCommitMessage(
  languages: string[]
): string {
  const langNames = languages.map(lang => getLanguageName(lang)).join(', ')
  return `docs(readme): Update translation list (${langNames})\n\nAuto-generated by GitHub Global`
}
